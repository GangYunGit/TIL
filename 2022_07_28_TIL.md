# 2022. 07. 28.

# 객체지향 복습

> 객체지향 패러다임이 나오게 된 이유

- 절차지향 : 호출한 순서대로 코드가 실행이 되는 방식

- 프로그램은 `확장성`이 있어야 한다.(첫 출발은 스타일 가이드)
  
  - 절차지향 방식은 프로그램이 커지게되면 변수가 너무 많아진다.(ex : 게임 이용자가 100명)

  - 절차지향 방식은 코드를 고칠 곳이 생기면 이용자의 변수 하나하나를 다 고쳐주어야 한다.

- 프로그램을 만들 때 `기능 vs 구조`에 초점을 맞출 것인지 결정하는데, `구조`에 초점을 맞춘 프로그래밍이 `객체지향`이다.

> 객체지향

- 클래스는 객체를 만드는 도구(설계도)일 뿐이다.

- **클래스를 통해 만들어진 객체는 `역할`, `책임`, `협력`을 갖는다.**
  
- 배틀쉽 게임의 경우 
  
  - 역할 : 플레이어, 
  - 책임 : 행위(배를 공격, 피격) 
  - 협력 : 요청, 응답

> 객체지향의 특성

- `추상화`, 캡슐화, 다형성, 상속 => 사실은 모든 것이 `추상화`에서 내려오는 개념.

- 클래스에 자료를 요청했을 때, 클래스 내부의 구조를 모르더라도 자료를 받기만 하면 그만이다.(커피를 주문하면 원두가 만들어지는 과정부터 커피를 추출해내는 과정 등을 몰라도 커피를 마실 수 있다.) => 추상화

- 다른 객체가 본 객체에 간섭하지 않고 자율적으로 맡긴다.(커피를 주문하면, 바리스타가 어떤 원두를 쓰든 어떤 믹서기로 갈든 상관하지 않는다.) => 캡슐화

  - getter : 객체의 상태를 조회하고 싶을 때, setter : 변수를 변경하고 싶을 때

- 어떤 객체가 오더라도 요청을 보냈을 때 동일한 응답이 오면 상관없다.(알바생이 바뀌어도 커피를 만들수만 있으면 된다.) => 다형성

- 추상화 => 캡슐화 => 다형성 => 그래서 상속이 가능
  
> 문법

- 인스턴스와 객체의 차이점(너무 구분지을 필요는 없다.)

  - 인스턴스 : `특정한 클래스(list, str, ...)의` 객체

  - 객체 : 객체 자체를 의미하는 말

  ```python
  a = '123' 

  b = list(a) # b는 리스트의 인스턴스, 혹은 그냥 객체
  # 리스트의 '역할'을 b에 부여
  # 리스트의 '책임' => 객체에 순서를 부여, 자료 수정이 가능

  b.append(3)  # append라는 메서드를 요청 => 3을 추가하여 응답 => '협력'

  print(b)
  ```

- 리스트는 시퀀스에게 상속을 받고, 시퀀스는 컨테이너를 상속받는다 => 리스트의 특성!

- 클래스 == 타입 : 객체 여러가지를 하나의 `타입`으로 모을 수 있다 => 추상화

- 프린트 내장함수는 str을 강제로 씌우고 변수를 출력한다. => `__str__매직 메서드`를 통해 객체를 문자열의 형태로 출력되게 만들 수 있다.

- 매직 메서드를 통해 특정 동작(연산, 출력 등)가 수행될 때 자동으로 호출되는 함수를 사용자가 직접 조작하여 기능을 추가할 수 있다.

- `del 키워드`는 객체를 지우는 것이 아니라 `변수가 객체를 가리키는 참조`를 없앤다. (변수에 붙어있던 포스트잇을 뗀다.)

- 클래스 메서드(@classmethond)에서는 클래스 변수를 직접 활용('cls.클래스변수'를 통해)할 수 있다
  
  - 인스턴스 메서드에서 클래스 변수를 `조회`하려면 'ClassName.클래스변수'를 써야함. 조회만 가능!

- 스태틱 메서드는 self가 필요가 없고(굳이 인스턴스 변수를 사용할 필요가 없다) 클래스 변수도 필요 없다면 사용하자. => 주로 변하지 않는 값을 출력할 때 사용

- 메서드 오버라이딩 : super()를 활용하여 상위 클래스의 메서드를 불러올 때에도 namespace룰이 적용된다 (바로 다음 상위 클래스 -> 그 다음 상위 클래스 -> ... -> 최고 클래스). 

- 스태틱 메서드에서는 super()를 쓸 수 없다. => self를 인자로 받지 못하여 문법적인 문제 발생

- Privae Member로 변수 선언 시 내부적으로 이름이 바뀌어(__age => Person__age로 바뀜) 접근이 불가능하게 막는다. 
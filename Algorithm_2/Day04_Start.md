# 2022. 09. 19.

## SW문제 해결

> 프로그래밍하기 위한 제약조건과 요구사항

- 프로그래밍 언어의 특성

- 프로그램이 동작할 HW와 OS에 관한 지식

- 라이브러리의 유의 사항들

- 프로그램이 사용할 수 있는 최대 메모리

- 사용자 대응 시간 제한

- 재사용성이 높은 간결한 코드

---

## 복잡도 분석

> 알고리즘의 효율

- 시간복잡도 분석
  
  - 하드웨어 환경에 따라 처리시간이 달라진다
    
    - 부동소수 처리 프로세서 존재 유무, 나눗셈 가속기능 유무
    - 임출력 장비의 성능, 공유 여부
  
  - 소프트웨어 환경에 따라 처리시간이 달라진다.
    
    - 프로그램 언어의 종류
    - 운영체제, 컴파일러의 종류

- 이러한 환경적 차이로 인해 분석이 어렵다.

> 복잡도의 점근적 표기

- 시간 (또는 공간)복잡도는 `입력 크기에 대한 함수`로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다

- 이를 단순한 함수로 표현하기 위해 점근적 표기 (Asymptotic Notation)을 사용한다.

- 입력 크기 n이 무한대로 커질 때의 족잡도를 간단히 표현하기 위해 사용하는 표기법이다.
  
  - O(Big-Oh) 표기
  - Ω(Big-Omega) 표기
  - Θ(Big-Theta) 표기

> O(Big-Oh) 표기

  ![image](https://user-images.githubusercontent.com/109258306/190938885-d428392c-9dc3-4830-80ac-fecae984b23f.png)

- O-표기는 복잡도의 점근적 상한을 나타낸다.

- 복잡도가 f(n) = 2n<sup>2</sup> - 7n + 4 이라면, f(n)의 O-표기는 O(n<sup>2</sup>)이다.

- f(n)의 단순화된 표현은 n<sup>2</sup>이다.

- 단순화된 함수 n<sup>2</sup>에 임의의 상수 c를 곱한 cn<sup>2</sup>이 증가함에 따라 f(n)의 상한이 된다.

- `단순히 "실행시간이 n<sup>2</sup>에 비례"하는 알고리즘이라고 말함`

> Ω(Big-Omega) 표기

  ![image](https://user-images.githubusercontent.com/109258306/190939652-6d73cdcc-2865-411a-88ae-d97768ae4bc4.png)

- 복잡도의 점근적 하한을 의미한다

- f(n) = 2n<sup>2</sup> - 7n + 4 이라면, f(n)의 Ω-표기는 Ω(n<sup>2</sup>)이다.

- f(n) = Ω(n<sup>2</sup>)은 `n이 증가함에 따라 2n<sup>2</sup> - 7n + 4dl cn<sup>2</sup>보다 작을 수 없다`라는 의미이다. 이때 상수 c=1

- `"최소한 이만한 시간은 걸린다"`는 의미

---

## 표준 입출력 방법

> 입력

- Raw 값의 입력 : input()
  
  - 받은 입력값을 문자열로 취급

- Evaluated된 값을 입력 : eval(input())
  
  - 받은 입력값을 평가된 데이터 형으로 취급

> 출력

- print() : 표준 출력 함수. 출력값의 마지막에 개행 문자 포함

- print('text', end='') : 출력 마지막에 개행문자를 제외할 때

- print('%d' % number) : Formatting된 출력

---

## 비트 연산

> 비트 연산자

- 논리 연산

| 연산자 | 연산자의 기능                                                   |
| :----: | :-------------------------------------------------------------- |
|   &    | 비트단위로 AND 연산을 한다. <br>ex) num1 & num 2                |
|   \|   | 비트단위로 OR 연산을 한다. <br>ex) num1 \| num 2                |
|   T    | 비트단위로 XOR 연산을 한다. <br>ex) num1 ^ num 2                |
|   ~    | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. <br>ex) ~num |

- shift 연산

| 연산자 | 연산자의 기능                                               |
| :----: | :---------------------------------------------------------- |
|   <<   | 피연산자의 비트열을 왼쪽으로 이동시킨다. <br>ex) num << 2   |
|   >>   | 피연산자의 비트열을 오른쪽으로 이동시킨다. <br>ex) num >> 2 |

> 1 << n

- 2<sup>n</sup>의 값을 갖는다.

- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

> i & (1 << j)

- 1을 j번 shift 연산하고 다시 i와 & 연산하고... 이렇게 하지 말고 
  
- `i의 j번째 비트가 1인지 검사`

---

## 엔디안(Endianness)

- 컴퓨터의 메모리와 같은 1차원 공간의 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍쳐마다 다르다.

> 빅 엔디안(Big endian)

- 보통 큰 단위가 앞에 나옴. 네트워크에서 쓰임

> 리틀 엔디안(Little endian)

- 작은 단위가 앞에 나옴. 대다수의 데스크탑 컴퓨터에서 쓰임
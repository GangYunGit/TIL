# 2022. 09. 15

# 내용 정리

> 알고리즘 전반기

- 리스트, 문자열 => Stack, Queue => 그래프 => DFS, BFS(`가중치가 없는 탐색`)

> 알고리즘 후반기에 배울 내용

- 트리 => 힙 => MST, 벨만포드, 플로이드 워셜

- MST => 크루스칼(`heap`개념 이용), 프림

- `가중치가 있는 그래프 탐색법` : 다익스트라(`heap`개념 이용)

- 번외 : CT, start, 그리디, 퀵정렬, 병합정렬

---

# 트리

> 트리의 개념

- `계층형 자료구조`

- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조

- root 노드(가장 상위의 원소), leaf 노드(더이상 뻗어나가지 않는 가장 하위의 원소)

## 트리를 도대체 왜 쓰는거지?

> 트리와 그래프의 차이

- 트리는 `그래프`의 한 종류이다.
  - 방향이 있는 그래프
  - 비순환(일방통행만 있음)
  - 부모가 1개

> 트리라는 개념은 왜 생겼나

- 트리의 본질은 `탐색` : 찾으려는 정보와 관련이 없는 파일들은 애초에 탐색에서 제외되어 효율이 증가

## 트리의 종류

- 포화, 완전, 편향

> `포화` 이진 트리

- 높이가 h이고 노드의 개수가 2^(h + 1) - 1 인 트리

- 리프 노드를 제외한 모든 노드의 자식노드가 2개

> `완전` 이진 트리

- 노드를 왼쪽부터 순서대로 읽었을 때 빈 자리가 없는 이진 트리

- 코드로 구현할 때 `메모리의 낭비가 적다`.

> 편향 이진 트리

- 자식이 한쪽 노드만 있는 이진트리

## 이진 트리 순회

> 3가지의 기본적인 순회 방법(`시험에 나올 수도 있다`)

- `부모`를 `어느 시점에 방문하는지`를 기준으로 나눈다.

- 전위 : `V`LR

- 중위 : L`V`R

- 후위 : LR`V`

## 이진 탐색 트리(Binary Search Tree)

- 시간복잡도: O(log n) => n번을 반으로 계속 쪼개서 탐색하면 최악의 경우 몇 번만에 도달하는지

---

# 힙(heap)

- `다익스트라`, `프림` 알고리즘에서 힙의 개념이 쓰인다.

- `최대값 또는 최소값이 항상 보장`된다. => 루트값을 pop하여 얻을 수 있다.

- `완전 이진 트리`에서만 사용이 가능하다.

- 삽입, 삭제하는 시간이 빠르다.

> 최대 힙

- 루트에 최대값이 있음 => 루트를 pop하면 최대값

- `각각의 부모노드가 두 자식보다 커야 한다`.

> 최소 힙

- 루트에 최소값이 있음 => 루트를 pop하면 최소값

- `각각의 부모노드가 두 자식보다 작아야 한다`.

> 힙의 삽입

- 부모노드와 자식노드를 비교하여 자리를 바꿔줌

- 시간복잡도 : O(log n)

> 힙의 삭제

- 과정
  - 일단 루트에 있는 원소를 삭제한다.
  - 가장 마지막에 있는 원소를 루트로 올려준다.
  - 부모와 자식노드 2개를 비교하여 가장 큰 값을 부모로 바꿔준다.
# 2022. 08. 18.

# Stack 복습

> DFS

- 스택, 재귀, 그래프(자료구조)를 배우는 이유 => DFS를 풀기 위해서.

- DFS, BFS는 무조건 익히고 가야한다.

> 용어 정리

- 자료(Data) : int, float 같은 것을 자료라고 하고, `메모리에 저장되는 데이터`를 말한다

- 자료 구조(Data Structure) : 데이터를 읽기, 쓰기, 삽입, 삭제, 탐색할 수 있는 `연산 기능을 제공`한다. => `메서드`와 같음

- 자료구조 == 데이터 + 연산 => 다수의 데이터를 효율적으로 저장하고 조작할 수 있으므로 `알고리즘 구현의 기본 재료`가 된다.

> Stack

- 마치 접시를 쌓고 빼듯이 데이터를 한쪽에서만 넣고 빼는 자료구조. `Last-in First-out, 후입선출`

- 스택 자료구조의 대표 연산
  
  - push : 새로운 데이터를 삽입
  - pop : 스택의 최신 데이터를 제거

---

# 재귀 복습

> 재귀

- 상위(원래) 문제를 해결하기 위해 하위의 문제를 먼저 해결하는 것.

> 피보나치 수열

- 종료조건(Base Case) : 0번째 항은 0, 1번째 항은 1의 피보나치 수. 따라서 n이 1이하면 n을 반환하고 재귀 종료

- 점화식 : 특정 항의 값은 앞 두 항의 합 => fibo(n) = fibo(n - 2) + f(n - 1)

> 동적 계획법

- 작은 부분을 먼저 해결한 후 큰 부분을 해결한다.

- 동적 계획법을 적용하기 좋은 조건
  - `하위 문제가 중복`될 때
  - `최적 부분 구조`를 가질 때

>> 메모이제이션

- 스택에 미리 저장해놓고 갖다 쓴다.

  ```python
  def: fibo(n):
      if len(memo) <= n:    # memo스택에 n번째 원소가 없으면 append로 채워줌
          memo.append(fibo(n -1)) + fibo(n - 2))
      return memo[n]

  
  memo = [0, 1]   # fibo(0)과 fibo(1)을 스택에 저장

  print(fibo(5))
  ```

---

# 그래프

> 그래프

- `정점(vertex)`와 `간선(edge)`들의 집합으로 이루어진 비선형 자료구조

- 현실에 있는 개체 간의 관계를 나타내기 위해 고안된 방법

> 인접 행렬, 인접 리스트

- 인접 행렬 : 그래프의 인접한 간선들을 행렬의 형태로 표현

- 인접 리스트 : 그래프를 연결 리스트를 통해 각 정점에 대한 인접 정점들을 순차적으로 표현하는 방식

---

# DFS

> DFS

- `모든 정점을 방문할 때 유리`하다, 따라서 `경우의 수, 순열과 조합 문제`에서 많이 사용한다.

> DFS 수행 조건

1. `그래프`

2. `방문처리 리스트`

3. 1번과 2번을 모두 수행했다면 `DFS` 수행

> DFS 사이클

- 스택의 최신 값이 가장 최근에 방문한 곳

- 인접한 정점을 확인하고 방문하는 정점을 stack에 쌓는다. visited[] 리스트에 해당 정점을 True처리

- 인접한 정점이 모두 방문한 곳(visited의 해당 정점이 True)이면 stack에서 pop을 하여 이전 정점으로 돌아감 

> `재귀(Recursion)을 이용한 DFS`

- 재귀로 푸는 이유? : 재귀함수와 스택의 원리가 같다.

- 함수는 호출 시 콜 스택에 쌓인다. => 함수 내에서 다른 함수가 호출되면 진행을 멈추고 다른 함수를 먼저 실행한다. 실행이 끝나면 호출 스택에서 해제되어 원래의 함수로 되돌아와 남은 부분을 진행한다.

  ```python
  def func1():
      func2()
      print('1번째 함수 발동!')
      
  def func2():
      func3()
      print('2번째 함수 발동!')
      
  def func3():
      print('3번째 함수 발동!')
    
  func1()
  # 3번째 함수 발동! => 출력 후 func3()이 호출 스택에서 해제
  # 2번째 함수 발동! => 출력 후 func2()이 호출 스택에서 해제
  # 1번째 함수 발동! => 출력 후 func1()이 호출 스택에서 해제되어 스택이 비게 됨
  ```

  ```python
  def func(n):
      if n <=3:
          func(n + 1)
          print(f'{n}번째 함수 발동!')

  func(1)
  ```